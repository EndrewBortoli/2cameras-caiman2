   * Returns the turn rate of the robot.
   *
   * @return The turn rate of the robot, in degrees per second
   */  
  
  public void autoAlignATest() {
    
    this.limelight = PhotonLL.getInstance();

    
    PIDController rotationPID = null;  
    PIDController carangueijoPID = null;
    PIDController forwardPID = null;
  
    double rotationOffset = 0;
    double carangueijoOffset = -0.25;
    double forwardOffset = 3.2;
  
    final SlewRateLimiter xLimiter, rotLimiter, yLimiter;
  
    rotLimiter = m_rotLimiter;
    xLimiter = m_magLimiter;
    yLimiter = m_magLimiter;

    // Controles PID para se alinhar
    carangueijoPID = new PIDController(0.2, 0, 0);
    rotationPID = new PIDController(0.2, 0, 0);
    forwardPID = new PIDController(0.2, 0, 0);
  
    double velCarangueijo = 0;
    double velRotation = 0;
    double velForward = 0;
    if (limelight.hasValueTargets()) {
        velCarangueijo = carangueijoPID.calculate(limelight.getXDistance(), carangueijoOffset);
        velRotation = rotationPID.calculate(limelight.getYaw(), rotationOffset);
        velForward = forwardPID.calculate(limelight.getArea(), forwardOffset);
            
        if (limelight.getYaw() > 175 && limelight.getYaw() < 5){
          velCarangueijo = 0.0;
          velRotation = 0.0;
          velForward = 0.0;
        }

    } else {
        velCarangueijo = 0.0;
        velRotation = 0.0;
        velForward = 0.0;
    }



    // SmartDashboard.putNumber("DRIVE OUTPUT", velForward);

  
    // 2. Apply deadband
    velCarangueijo = Math.abs(velCarangueijo) > OIConstants.kDriveDeadband ? velCarangueijo : 0.0;
    velRotation = Math.abs(velRotation) > OIConstants.kDriveDeadband ? velRotation : 0.0;
    velForward = Math.abs(velForward) > OIConstants.kDriveDeadband ? velForward : 0.0;
  
    // 3. Make the driving smoother
    velForward = yLimiter.calculate(velForward) * 3;
    velCarangueijo = xLimiter.calculate(velCarangueijo) * 3;
    velRotation = rotLimiter.calculate(velRotation) * 5;

    // SmartDashboard.putNumber("giro output", velRotation);
    // SmartDashboard.putNumber("GIRO GOAL", rotationPID.getGoal().position);

  
    // Construct desired chassis speeds
    ChassisSpeeds chassisSpeeds = new ChassisSpeeds(velForward, velCarangueijo, velRotation);
  
    // Set chassis speeds using existing method
    setChassisSpeeds(chassisSpeeds);
  }

  public void autoAlignX() {
    
    this.limelight = PhotonLL.getInstance();

    
    PIDController rotationPID = null;  
  
    double rotationOffset = 0;
  
    final SlewRateLimiter xLimiter, rotLimiter, yLimiter;
  
    rotLimiter = m_rotLimiter;
    xLimiter = m_magLimiter;
    yLimiter = m_magLimiter;
  
    // Controles PID para se alinhar
    rotationPID = new PIDController(0.4, 0, 0);
  
    double velCarangueijo = 0;
    double velRotation = 0;
    double velForward = 0;
    if (limelight.hasValueTargets()) {
        velRotation = rotationPID.calculate(limelight.getYaw(), rotationOffset);
            
        if (limelight.getYaw() > 175 && limelight.getYaw() < 5){
          velCarangueijo = 0.0;
          velRotation = 0.0;
          velForward = 0.0;
          System.out.println("Se alinhou");
        }

    } else {
        velCarangueijo = 0.0;
        velRotation = 0.0;
        velForward = 0.0;
    }

    

    // SmartDashboard.putNumber("DRIVE OUTPUT", velForward);

    velRotation = Math.abs(velRotation) > OIConstants.kDriveDeadband ? velRotation : 0.0;
  
    // 3. Make the driving smoother
    velRotation = rotLimiter.calculate(velRotation) * 5;

    // SmartDashboard.putNumber("giro output", velRotation);
    // SmartDashboard.putNumber("GIRO GOAL", rotationPID.getGoal().position);

  
    // Construct desired chassis speeds
    ChassisSpeeds chassisSpeeds = new ChassisSpeeds(velForward, velCarangueijo, velRotation);
  
    // Set chassis speeds using existing method
    setChassisSpeeds(chassisSpeeds);
  }

  public boolean isAlignedNote() {
    if (m_LimelightObject.getXLimelight() < 5 & m_LimelightObject.getXLimelight() > -5) {

      vision = true;
      return true;

    } else {

      vision = false;
      return false;

    }
  }
  public boolean isAlignedPV() {
    if(limelight.correctID(3)){
      this.limelight = PhotonLL.getInstance();
      if (limelight.getYaw() < 20 & limelight.getYaw() > 10) {
      return true;
    } else {
      return false;
    }
  } else {
    return false;
  }
    
  }

 public void autoAlignLeft() {
    
this.limelight = PhotonLL.getInstance();

    
    PIDController rotationPID = null;  
  
    double rotationOffset = 0;

  
    final SlewRateLimiter xLimiter, rotLimiter, yLimiter;
  
    rotLimiter = m_rotLimiter;
    xLimiter = m_magLimiter;
    yLimiter = m_magLimiter;
  
    // Controles PID para se alinhar
  
    double velRotation = 0;


    if (limelight.hasValueTargets()) {
      if(isAlignedPV() == false)
        if(limelight.getYaw() < 20 ) {
        velRotation = 0.1;
        } else if ( limelight.getYaw() > 10) {
          velRotation = -0.1;
        }
    } else {
      velRotation = -0.15;
    }

    // SmartDashboard.putNumber("getXDistance?", limelight.getXDistance());
    // SmartDashboard.putNumber("velRotation?", velRotation);


    velRotation = Math.abs(velRotation) > OIConstants.kDriveDeadband ? velRotation : 0.0;
  
    // 3. Make the driving smoother
    velRotation = rotLimiter.calculate(velRotation) * 5;

    // Construct desired chassis speeds
    ChassisSpeeds chassisSpeeds = new ChassisSpeeds(0, 0, velRotation);
  
    // Set chassis speeds using existing method
    setChassisSpeeds(chassisSpeeds);
  }

  public void autoAlignRight() {
    
    this.limelight = PhotonLL.getInstance();

    
    PIDController rotationPID = null;  
  
    double rotationOffset = 0;

  
    final SlewRateLimiter xLimiter, rotLimiter, yLimiter;
  
    rotLimiter = m_rotLimiter;
    xLimiter = m_magLimiter;
    yLimiter = m_magLimiter;
  
    // Controles PID para se alinhar
  
    double velRotation = 0;


    if (limelight.hasValueTargets()) {
      if(isAlignedPV() == false)
        if(limelight.getYaw() < 20 ) {
        velRotation = 0.1;
        } else if ( limelight.getYaw() > 10) {
          velRotation = -0.1;
        }
    } else {
      velRotation = 0.15;
    }

    // SmartDashboard.putNumber("getXDistance?", limelight.getXDistance());
    // SmartDashboard.putNumber("velRotation?", velRotation);


    velRotation = Math.abs(velRotation) > OIConstants.kDriveDeadband ? velRotation : 0.0;
  
    // 3. Make the driving smoother
    velRotation = rotLimiter.calculate(velRotation) * 5;

    // Construct desired chassis speeds
    ChassisSpeeds chassisSpeeds = new ChassisSpeeds(0, 0, velRotation);
  
    // Set chassis speeds using existing method
    setChassisSpeeds(chassisSpeeds);
  }

  LimelightObject m_LimelightObject = LimelightObject.getInstance();  // Use the existing instance


  
  public void autoAlignNote() {
    

    PIDController rotationPID = null;  
    PIDController forwardPID = null;
  
    double rotationOffset = 0;
    double forwardOffset = 3.2;

    final SlewRateLimiter yLimiter, rotLimiter;
  
    rotLimiter = m_rotLimiter;
    yLimiter = m_magLimiter;

  
    // Controles PID para se alinhar
    rotationPID = new PIDController(1, 0, 0);

  
    double velRotation = 0;
    double velForward = 0;
  
    if (m_LimelightObject.hasObject()) {
        if (!isAlignedNote()) {
            if(m_LimelightObject.getXLimelight() < 0) {
        velRotation = -0.1;
        
      } else {
        velRotation = 0.1;
      }
        } 
        if (isAlignedNote()) {
            velRotation = 0;
          } 
    } else {
      if(m_LimelightObject.getXLimelight() < 0) {
        velRotation = 0.25;
      } else {
        velRotation = -0.25;
      }
    }

    SmartDashboard.putBoolean("objectIsSeen?", m_LimelightObject.objectIsSeen());
    SmartDashboard.putBoolean("hasObject?", m_LimelightObject.hasObject());
    SmartDashboard.putBoolean("isAlignedNote?", isAlignedNote());
    // SmartDashboard.putNumber("velRotation",velRotation);
    // SmartDashboard.putNumber("rotationOffSet",rotationOffset);
    // 2. Apply deadband
    velRotation = Math.abs(velRotation) > OIConstants.kDriveDeadband ? velRotation : 0.0;
    velForward = Math.abs(velForward) > OIConstants.kDriveDeadband ? velForward : 0.0;
  
    // 3. Make the driving smoother
    velRotation = rotLimiter.calculate(velRotation) * 5;
    velForward = yLimiter.calculate(velForward) * 3;

    // Construct desired chassis speeds
    ChassisSpeeds chassisSpeeds = new ChassisSpeeds(velForward, 0, velRotation);
  
    // Set chassis speeds using existing method
    setChassisSpeeds(chassisSpeeds);
}

